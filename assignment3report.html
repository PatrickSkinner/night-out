<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
    <head>
        <title>Assignment 3</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>


    <body>
        <h1> Assignment 3 </h1>
        <h2>Matthew Lang,
            Patrick Skinner,
            Cassidy Mowat,
            Josiah Hunt,
            Dylan Pringle,
        </h2>
        <h2>Emulator Interface</h2>
        <p>
        <p>/**<br>
            * Create a new button object and draw it to the screen.<br>
            * <br>
            * @param {number} x - X coordinate of top left corner.<br>
            * @param {number} y - Y coordinate of top left corner.<br>
            * @param {number} w - Width of button, in pixels.<br>
            * @param {number} h - Height of button, in pixels.<br>
            * @param {string} c - Color of the button. as a hex value.<br>
            * @param {string} sc - Color of the buttons shadow. as a hex value.<br>
            * @param {function} onClickFunction - The function to be called when the button is clicked.<br>
            * @param {object} data - An object containing all the parameters of the function as data fields.<br>
            * @returns {undefined}<br>
            */<br>
            function createButton(x, y, w, h, c, sc, onClickFunction, data) {}<br>
        </p>
        <p>
            /**<br>
            * Create a new button object no associated visual element.<br>
            * <br>
            * @param {number} x - X coordinate of top left corner.<br>
            * @param {number} y - Y coordinate of top left corner.<br>
            * @param {number} w - Width of button, in pixels.<br>
            * @param {number} h - Height of button, in pixels.<br>
            * @param {function} onClickFunction - The function to be called when the button is clicked.<br>
            * @param {object} data - An object containing all the parameters of the function as data fields.<br>
            * @returns {createButtonObject.createdButton} - Return a reference to the created button object.<br>
            */<br>
            function createButtonObject(x, y, w, h, onClickFunction, data) {}<br>
        </p>
        <p>
            /**<br>
            * Check if a mouse click is within the bounds of a button.<br>
            * <br>
            * @param {number} x - X coordinate of mouse click.<br>
            * @param {number} y - Y coordinate of mouse click.<br>
            * @param {number} objX - X coordinate of the buttons top left corner.<br>
            * @param {number} objY - Y coordinate of the buttons top left corner.<br>
            * @param {number} objW - Width of button, in pixels.<br>
            * @param {number} objH - Height of button, in pixels.<br>
            * @returns {Boolean} - True if the mouse click was within the the bounds of a button.<br>
            */<br>
            function withinBounds (x, y, objX, objY, objW, objH) {}<br>
        </p>
        <p>
            /**<br>
            * Return a list of all buttons that are currently active.<br>
            * <br>
            * @returns {Array|buttons|button1} - An array of all the buttons currently on screen.<br>
            */<br>
            function getButtons(){}<br>
        </p>
        <p>
            /**<br>
            * Clear all currently active buttons.<br>
            * <br>
            * @returns {undefined}<br>
            */<br>
            function clearButtons(){}<br>
        </p>
        <p>
            /**<br>
            * Return the x, y coordinates of a mouse click.<br>
            * <br>
            * @param {type} evt<br>
            * @returns {onClick.EmulatorAnonym$0} - Return an object with the x and y coordinates of the mouse click as data fields.<br>
            */<br>
            function onClick(evt){}<br>
        </p>
        <p>
            /**<br>
            * Draw a rectangle.<br>
            * <br>
            * @param {number} x - x coordinate of rectangles top left corner.<br>
            * @param {number} y - y coordinate of rectangles top left corner.<br>
            * @param {number} w - width of rectangle.<br>
            * @param {number} h - height of rectangle.<br>
            * @param {String} c - Color of the rectangle, as a hex value.<br>
            * @returns {undefined}<br>
            */<br>
            function drawRect(x, y, w, h, c){}<br>
        </p>
        <p>
            /**<br>
            * Draw a line between two points.<br>
            * <br>
            * @param {number} x1 - x coordinate of lines start point.<br>
            * @param {number} y1 - y coordinate of lines start point.<br>
            * @param {number} x2 - x coordinate of lines end point.<br>
            * @param {number} y2 - y coordinate of lines end point.<br>
            * @returns {undefined}<br>
            */<br>
            function drawLine(x1, y1, x2, y2){}<br>
        </p>
        <p>
            /**<br>
            * Draw a circle.<br>
            * <br>
            * @param {number} x - x coordinate of circles center.<br>
            * @param {number} y - y coordinate of circles center.<br>
            * @param {number} r - radius of the circle.<br>
            * @returns {undefined}<br>
            */<br>
            function drawCircle(x, y, r){}<br>
        </p>
        <p>
            /**<br>
            * Draw a string of text.<br>
            * <br>
            * @param {number} x - x coordinate of text.<br>
            * @param {number} y - y coordinate of text.<br>
            * @param {string} text - String to be displayed.<br>
            * @param {string} c - Color of text as a hex value.<br>
            * @param {number} s - Point size of text.<br>
            * @param {string} font - Desired font.<br>
            * @returns {undefined}<br>
            */<br>
            function drawText(x, y, text, c, s, font){}<br>
        </p>
        <p>
            /**<br>
            * Draw an image to screen.<br>
            * <br>
            * @param {number} x - x coordinate of images top left corner.<br>
            * @param {number} y - y coordinate of images top left corner.<br>
            * @param {Image} img - The image to be drawn.<br>
            * @returns {undefined}<br>
            */<br>
            function drawImage(x, y, img){}<br>
        </p>
        <p>
            /**<br>
            * Draw a button with a standard style.<br>
            * <br>
            * @param {number} x - X coordinate of top left corner.<br>
            * @param {number} y - Y coordinate of top left corner.<br>
            * @param {number} w - Width of button, in pixels.<br>
            * @param {number} h - Height of button, in pixels.<br>
            * @param {string} colour - Color of the button. as a hex value.<br>
            * @param {string} shadowColour - Color of the buttons shadow. as a hex value.<br>
            * @returns {undefined}<br>
            */<br>
            function drawButton(x, y, w, h, colour, shadowColour){}<br>
        </p>
        <p>
            /**<br>
            * Clear the canvas.<br>
            * <br>
            * @returns {undefined}<br>
            */<br>
            function clear(){}<br>
        </p>
        <p>
            /**<br>
            * Draw a static map with a marker on the given location.<br>
            * <br>
            * @param {object} obj - An object holding the longitude and latitude of a location as data fields.<br>
            * @returns {undefined}<br>
            */<br>
            function mapTest(obj){}<br>
        </p>
        <p>
            /**<br>
            * Create a dynamic map with a route draw between the userLocation and the given location.<br>
            * <br>
            * @param {type} targetLocation - An objecting holding the longitude and latitude of a location as data fields.<br>
            * @returns {undefined}<br>
            */<br>
            function initDirection(targetLocation) {}<br>
        </p>
        <p>
            /**<br>
            * Update the userPosition object with the browsers geolocation capabilities.<br>
            * <br>
            * @returns {undefined}<br>
            */<br>
            function updateLocation() {}<br>
        </p>
        <p>
            /**<br>
            * Open a given URL in a new tab.<br>
            * <br>
            * @param {string} url - A URL to be opened in a new tab by the browser.<br>
            * @returns {undefined}<br>
            */<br>
            function webRedirect(url){}<br>
        </p>
        <p>
            /**<br>
            * Get canvas and mapDiv elements and assign them to global variables, add button click listener.<br>
            * <br>
            * @returns {undefined}<br>
            */<br>
            function init(){}<br>
        </p>
        <p> To use the emulator the application should be loaded from index.html in place of the existing Application.js file, the application can then be launched by opening the index.html page. The index
            page will provide a 320x320 canvas as well as a 320x320 div used to draw a Google map object, this div is placed on top of the canvas but can be toggled on or off by changing the CSS style. </p>
        
        <p>
        The emulator provides a series of basic drawing functions to the application, including basic shapes, text, and images. Two functions are provided for the creation of new buttons, one which creates a new button object
        and another that creates a new button object and draws an appropriate graphic, both functions add the button to the button array. The button array holds all the buttons that are currently active, and should be cleared each
        time the application draws a new screen. When a new button is created a function is passed as a parameter, this is the function that's called when the button is clicked, if the function is to be called with parameters
        then the "data" field of the button should contain an object with the appropriate parameters as data fields, this is too allow a varying amount of parameters being passed to a function.
        </p>
        
        <p>
        The application should be structured such that each page/screen is its own function. Each of these functions should begin by clearing the screen and the buttons array with the appropriate emulator functions
        a new button can be created with the a default graphical stlye with the createButton function, or with no visual component with the createButtonObject function, so art assets can be manually placed
        over the buttons location. The emulator holds a "userLocation" object that stores the users latitude and longitude, this can updated by calling the updateLocation method. This object is used
        in the initDirections and getDistance functions, which use the users location in conjunction with a passed in LatLng object.
        </p>

        <h2> How the Application works </h2>
        <p>
            Load the Index.html file, this loads both the emulator and the application files, and creates a new canvas for the emulator to run inside. Ensure that geolocation is supported and 
            enabled in your browser. The application is simple to use, first off it gives you four different options, this includes Food, Pub, Clubs and Taxi. You can click on any of them which loads up 
            a list of venues or services. Click a venue takes you too an information display screen about the venue, this screen includes a link to the venues website, and a "Get directions" button that loads a map with directions to the location chosen from your 
            current position. Back buttons are on every screen allowing the user to get back to the first four main options. 
        </p>
      
        
        <h2>Tools we used</h2>
        <p>
            We used Netbeans as our chosen IDE, our initial report outlined how we were already familiar with Netbeans and it's GitHub integration. This allowed us to use version control 
            very effectively and often which helped greatly with us each working on different parts of the application and emulator simultaneously. We were all happy with our choice of IDE and would happily use
	    it for another software development project.Another advantage of Netbeans was the built in JSTestDriver service, which was the library we used to create the test cases and run the emulator and application unit tests, allowing us to easily run them simultaneously in different browsers
            such as Firefox, Safari and Chrome. NetBeans also supported JSDoc, which allowed us to easily comment all our code, and export the comments as HTML to create our interface documentation. 2D art assets were created with Photoshop and Inkscape, Photoshop was again chosen due to familiarity, while Inkscape was used as it is a freely available piece of Open Source
            software.
        </p>
        
        <h2>Testing & Compatibility</h2>
        <p>
        Our application is known to work perfectly in Chrome, Safari, and Firefox. We had no problems with our application behaving differently between any of the browsers we tested, this was likely due to our reliance on pure Javascript, with a only
        handful of lines of HTML and CSS contained in our index file. This ensured our application and emulator would run the same in any browser that supported the HTML5 canvas and geolocation. The JSTestDriver functionality made the test
        process easy and let us easily run our tests in all browsers with a single click, we made sure we ran the test suite before pushing any commits to the main branch.
        </p>

        <h2>Personal Experiences</h2>
        <h3>Matthew Lang</h3>
        <p>
            My role in the group was unit testing, and doing any odd job that was needed by the group, the difficulties of Making test cases in a new language was a new experience, 
            it was hard not knowing what could work in the tests and how I could try to break the functions I was given to test. Also working with a large group and with git was very interesting
            and getting everyone to meet up was a hard task.
            </p>
        
        <h3>Dylan Pringle</h3>
        <p>
            My role in the group was UI/logo artwork and design. My main tool I used was Adobe Photoshop CS3. Artwork and design inspiration originated from visualizing what mood 
            our target audience would be in when using our application. Our audience will be craving a fun, social experience, so I decided to use bright attractive colors for 
            buttons and panels to reflect this sense of fun and excitement. The biggest frustration I faced while designing was that the bright colors would sometimes make 
            intricate details in the app difficult to see because of its small UI. Colors would also occasionally clash with each other. These issues required delicate blending 
            and tweaking of colors. This was not a huge issue but did take some experimentation and time to get right.
            As a group I feel we all worked very well together. We divided up roles and tasks effectively even though we had five members in the group. We were always able to 
            discuss ideas and issues cohesively while at all times remaining very positive and encouraging towards each other. We worked mostly during weekends together in the 
            university labs so we had very good close communication when putting all the applications pieces together. I would happily work with my group members again in the 
            future.
        </p>
        
        <h3>Patrick Skinner</h3>
        <p>
            My role in the group was to outline the design of application and create the emulator. I did both these tasks as the functionality provided by the emulator was dictated by the 
            proposed design of the application and the functionality it would require. I limited the functionality of the emulator to what was needed by our application, every function in the
            emulator was used by the application at some point. I was not familiar with Javascript before this assignment, but took it as an opportunity to learn and found that it suited
            the needs of the project perfectly, though I would consider learning Dart or Typescript if I had to do a similar project of a larger scope.
        </p>
        <h3>Cassidy Mowat</h3>
        <p>
        My role in the group was focusing on programming the application side of the project. I found this a challenging task to begin with as it was my first serious experience with javascript,
        however once I got used to this new language things became a lot easier. Our chosen IDE (NetBeans) turned out to be very helpful for me when I was unsure about some type of new syntax,
        I would be happy to use NetBeans again for any other future projects. Overall I enjoyed working on the project and I feel that it has helped me improve many of my skills. Working in a group
        of this size was an interesting experience, I found that for the most part we worked well by giving everyone separate tasks. The only issues we ran into were having trouble getting everyone
        to meet up at times, and a lack of communication from a certain member at times.
        </p>
        
        <h3>Josiah Hunt</h3>
        <p>My role in the group was focused on programming the application side. I interfaced with the Google Maps API to allow for direction maps, as well as being tasked with implementing the button 
        functionality. While I was comfortable with Javascript, the Netbeans IDE took a bit of getting used to, although once I got the hang of it I found it to be extremely powerful. The most challenging 
        part I faced was thinking of how I could write code in the most general way possible to allow for many different functions to be mapped to a button object. </p>
    </body>
</html>
